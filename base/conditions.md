# Условные конструкции

## Условия

В прошлой статье мы вкратце рассмотрели такой тип данных как `bool`. Хранить он в себе может два значения - либо `true` (истина), либо `false` (ложь). Через `bool` мы можем выразить множество суждений, например что небо синее или то, что на дворе идёт снег. Можно сказать что это такие же условия:

```csharp
skyIsBlue = true;  // Да, небо голубое
itIsSnows = false; // Нет, сейчас лето
```

Однако в таком виде всё достаточно скучно, для того чтобы использовать полную мощь булевой логики к нам на помощь приходит множество различных логических операторов и конструкций.

## Об операторах

Поговорим немного об операторах, они делятся на два вида: те, которые оперируют с одним операндом и двумя. Первый назвали унарным, второй бинарным (логично). Типичный пример унарного оператора это знак минус `-a` (получаем противоположное число), а типичный пример бинарного оператора это знак сложения `a + b`.

### Арифметические

Также помимо минуса в C# есть ещё несколько интересных унарных операторов инкрементный и декрементный. Так как программисты достаточно ленивые существа, а расписывать тот факт, что число увеличивает себя на единицу нужно было довольно-таки часто, при этом сама подобная запись занимала много символов, были придуманы два таких оператора:

```csharp
int i = 0;
i++; // Инкремент, i = 1 (i = i + 1)
i--; // Декремент, i = 0 (i = i - 1)
```

Это постфиксная форма, также есть префиксная:

```csharp
int i = 0;
++i; // i = 1 (i = i + 1)
--i; // i = 0 (i = i - 1)
```

В чём различие? В данном примере никакого, но вот в следующем можно заметить разницу:

```csharp
int i = 0;
int b = i++; // b = 0, i = 1
int c = ++i; // c = 2, i = 2
```

Тоесть можно вывести логику, если мы пишем плюс или минус в начале, то число сначала инкрементируется и потом только присваивается. Если пишем после, то идёт сначала присвоение, а потом только инрементирование.

---

Рассмотрим также основные арифметические бинарные операторы, вот они слева направо: `*` (умножение), `/`(деление), `%`(остаток), `+` (сложение), `-` (вычитание). При делении целых чисел возвращается число, округлённое в меньшую сторону. Рассмотрим пример:

```csharp
int a = 8;
int b = 5;

Console.WriteLine(a * b); // 45
Console.WriteLine(a / b); // 1
Console.WriteLine(a % b); // 4
Console.WriteLine(a + b); // 14
Console.WriteLine(a - b); // 4
```

Помимо обычной у них ещё есть сокращённая форма, которая выражается как `op=`, данную запись можно интерпетировать так `a op= b --> a = a op b`. Рассмотрим примеры:

```csharp
int a = 8;

a *= 5;  // 40 (a = a * 5)
a /= 4;  // 10 (a = a / 4)
a %= 3;  // 1  (a = a % 3)
a += 14; // 15 (a = a + 14)
a -= 6;  // 9  (a = a - 6)
```

### Логические

В C# также есть уйма логических операторов, как несложно догадаться результатом их работы является логическое выражение, тоесть `bool`. Начнём мы с оператора логического НЕ, выглядит он так:

```csharp
bool isSummer = true;
bool isWinter = !isSummer; // false
```

Иными словами он просто меняет значение на противоположное. Для того чтобы проверить, что переменная равна или не равна какому-либо значению мы используем оператор двойного равно `==`, для того чтобы проверить обратное - НЕ равно `!=`.

```csharp
int a = 5;
bool check;

check = a == 5; // true
check = a != 5; // false 
```

Как видно, если бы вместо двойного было обычное равно, то это могло бы создать множество конфузий и сделало бы код менее читаемым. Перейдём к операторам которые проверяют отношения больше-меньше: `>` (больше), `<` (меньше), `>=` (больше или равно), `<=` (меньше или равно). Первые два оператора проверяют строгое отношение, последние два учитывают само число.

```csharp
int a = 10;

Console.WriteLine(a > 10);  // false
Console.WriteLine(a < 11);  // true
Console.WriteLine(a >= 10); // true
Console.WriteLine(a <= 9);  // false
```

Теперь перейдём к самой мякотке: `&` (логическое И), `|` (логическое ИЛИ). Первый оператор возвращает `true` только если оба его операнда равны `true`, второй только если один из. Логическое И можно рассматривать как логическое умножение (умножаем на ноль, всё превращается в ноль), а логическое или как логическое сложнение (добавляем единицу, всё выражение теперь больше или равно единице).

```csharp
bool check;

check = true & true;   // true
check = false & true;  // false
check = false | false; // false
check = true | false;  // true
```

Как можно заметить, мы делаем ненужные вычисления. Зачем нам смотреть на второй операнд в логическом И, если первый всё равно ложный. Или зачем нам смотреть на второй операнд в логическом ИЛИ если первый всё равно истинный. Также заместо обычных `true` или `false` могут быть достаточно сложные вычисления. На помощь нам приходят операторы `&&` и `||`.

Для того чтобы лучше понять принцип работы данных операторов можно представить конвейер, по которому у нас идут логические выражения. Если мы используем логическое И и оператор видит, что первый операнд ложен, то конвейер останавливается, и возвращается `false`. Если используем логическое ИЛИ то конвейер останавливается когда замечает `true`.

```csharp
int a = 5;
bool check;

check = a > 5 & a < 9 & a % 2 == 1;
    // false И true И true

check = a > 5 && a < 9 && a % 2 == 1;
    // false, конвейер остановился на первом выражении

check = a > 5 | a < 9 | a % 2 == 1;
    // false ИЛИ true ИЛИ true

check = a > 5 || a < 9 || a % 2 == 1;
    // false ИЛИ true, остановился на втором
```

Пока что мы не можем проверить наверняка, рассчиталось ли второе или третье выражение. Мы вспомним про данный оператор далее когда будем проходить функции.

## If else 

Допустим нам нужно сделать какое-то действие только лишь в том случае, когда выполняется определённое условие. Самой простой конструкцией для подобного рода задач является `if (условие)`

```csharp
int a = 5;

if (a > 4)
    Console.WriteLine("a больше 4"); 
        // Выводится
```

Говоря простым языком в скобки мы подставляем то, что возвращает или имеет логическое выражение. Например если мы подставим в скобки переменную с типом `bool`, нам не нужно дополнительно проверять его на `true`.

```csharp
int a = 5;
bool check = a > 4;

if (check)
    Console.WriteLine("a > 4"); 
        // Выводится
```

Также если нам нужно выполнять это лишь в том случае, когда условие ложно, мы можем просто использовать логическое НЕ.

```csharp
int a = 5;
bool check = a < 5;

if (!check)
    Console.WriteLine("a больше или равно 5"); 
        // Выводится
```

Допустим нам нужно сделать больше, чем просто просто вывод в консоль, тогда мы можем использовать фигурные скобки.

```csharp
int a = 5;

if (a > 4) {
    a--;
    Console.WriteLine(a); // Вывод: 4
}
```

На самом деле фигурные скобки лучше писать, чтобы не путаться, в контексте данного руководства они отбрасываются для лучшей интерпретации. Если нам нужно выполнять 2 действия в зависимости от условия, то можно восользоваться `else` таким образом:

```csharp
int a = 5;

if (a > 5) 
    Console.WriteLine("a больше 5");
else
    Console.WriteLine("a меньше или равно 5");

// Вывод: a меньше или равно 5
```

В случаях когда может быть промежуточное условие, можно использовать `else if`

```csharp
int a = 5;

if (a > 5)
    Console.WriteLine("a больше 5");
else if (a == 5)
    Console.WriteLine("a равно 5");
else
    Console.WriteLine("a меньше 5");
```

## Switch case

Если условий слишком много, то лучше подумать о том, чтобы воспользоваться условной конструкцией `switch (x) case`. В данной конструкции мы используем лишь одно логическое выражение: `==`. Т.е. использовать данную конструкцию можно тогда, когда число может иметь несколько значений, и в зависимости от значения выполнять различные действия. Мы пишем в круглые скобки переменную, по значению которой мы будем выполнять действия, затем фигурные скобки и отдельный случаи (кейсы). При этом каждый случай должен оканчиваться словом `break`.

```csharp
int a = 5;

switch (a) {
    case 5:
        Console.WriteLine("a равно 5");
        break;
    case 6:
        Console.WriteLine("a равняется 6");
        break;
    case 10:
        Console.WriteLine("a больше 9");
        break;
    case 12:
        Console.WriteLine("a меньше 13");
        break;
}

// Вывод: a равно 5
```

Если есть несколько значений, при которых происходит одинаковое действие, то можно их вложить друг в друга.

```csharp
int a = 5;

switch (a) {
    case 5: case 6:
        Console.WriteLine("a равно либо 5, либо 6");
        break;
}

// Вывод: a равно либо 5, либо 6
```

---

В случае когда мы хотим, чтобы при соблюдении одного значения выполнялось одно действие, а потом оно переходило в другой кейс и производилось дополнительное действие мы можем воспользоваться волшебным выражением `goto`. Почему волшебным? А потому что при неаккуратном использование он может превратить программу в лапшу, где будет очень сложно понять как ведёт себя программа. Рассмотрим самый простой пример с ним.

```csharp
int a = 5;

switch (a) {
    case 5:
        a++;
        Console.WriteLine("a равно 6");
        goto case 6;
    case 6:
        a -= 5;
        Console.WriteLine("a равно 1");
        break;
}

// Вывод: a равно 6
//        a равно 1
```

Теперь рассмотрим пример потяжелее:

```csharp
int a = 5;

switch (a) {
    case 2:
        a *= 3;
        break;
    case 4:
        a %= 3;
        goto case 8;
    case 5:
        a++;
        goto case 4;
    case 7:
        a -= 3;
        goto case 4;
    case 8:
        a += 4;
        goto case 2;
    case 12:
        a *= 5;
        break;
}

Console.WriteLine(a); // Вывод: 12
```

Можно подойти к выводу, что данным выражением нужно пользоваться очень аккуратно и только тогда, когда это будет иметь смысл.