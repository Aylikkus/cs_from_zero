# Функции

## Что такое функция

Когда мы говорим про функции нам сразу же вспоминается математика, но к сожалению математическое определение функции может нам не подойти, если мы не пользуемся функциональными языками программирования. Математика говорит нам, что функция это соответствие между элементами двух множеств, причём каждому элементу одного множества ставится в соответствие элемент другого множества. Почему не подойдёт? А потому что когда мы программируем, при подаче одного и того же аргумента в функцию мы не будем стабильно получать один и тот же результат. Например если у нас будет функция получения прогноза погоды с какого-то сайта на определённую дату, когда мы вызываем эту функцию при одних и тех же параметрах, то мы можем получим ошибку (сайт недоступен, заблокирован доступ и т.д), либо погода может даже измениться. Как видно, чёткого соответсвия нет.

В программировании функция это больше кусок кода, к которому мы можем обратиться для выполнения. У данной функции может быть имя, также функция может иметь возвращаемое значение (тип данных, результат) и аргументы (то, что подаётся на вход).

## Примеры в C#

Для объявления самой простой функции нам нужно написать тип данных, имя самой функции и её параметры(они могут быть пустые, но скобки писать всё равно нужно). Если у нас нет возвращаемого значения, то тип возвращаемого значения `void`. Если же у нас есть возвращаемое значение, то все пути функции должны его возвращать через ключевое слово `return`. Например:

```csharp
/*
<тип данных> <имя функции>(<аргумент1>, <аргумент2>)
{
    return <тип данных>;
}
*/

int sum(int a, int b)
{
	return a + b;	
}

// Вызов осуществляется также через круглые скобки, 
// где заместо аргументов мы подставляем реальные значения
// или проинициализированные переменные такого же типа данных
Console.WriteLine(sum(3, 2));
    // Вывод 5
```

```csharp
void printConcat(string a, string b)
{
    Console.WriteLine(a + b);
}

string first = "Hello";
string second = " World!";

printConcat(first, second);
```

Функции могут быть настолько большими, насколько вы того захотите, однако лучше придерживаться той логики которую вы пишете в названии функции (для того чтобы понимать что делает конкретно эта функция). Когда мы говорили про логические операторы мы затронули такие операторы как `&&` и `||`. Сейчас с помощью функций можно будет показать принцип их работы.

```csharp
bool someBoolFunc(int a, int b)
{
    Console.WriteLine("Функция сработала");
    return a > b;
}

bool someCheck = 3 > 2 && 5 < 1 && someBoolFunc(3, 2);
    // Вывода нет

bool someCheck1 = 10 > 1 && someBoolFunc(1, 2);
    // Вывод: Функция сработала
```

## Про методы

Когда мы пользуемся языками ООП, коим C# и является, то заместо слово "функция" мы используем слово "метод". Связано это больше с объектами, так как у каждого объекта могут быть свои методы, и как можно увидеть звучит это гораздо логичнее чем: "у каждого объекта могут быть свои функции". У собаки например есть метод гавкнуть, но вряд-ли есть такая функция, думаю вы понимаете к чему я клоню. =)

Слово "функция" больше свойственно чисто императивным языкам программирования и функциональным. В процедурной есть такое понятие как "процедура". В ООП же все функции именуется методами, так что в дальнейшем я не буду использовать слово функция.

## `params`

В предпоследнем примере мы рассмотрели такой метод как конкатенация строк. Законный вопрос, а можем ли мы подавать на вход бесконечное количество строк, при этом чтобы работа метода была таким же? И ответ да. Мы можем в параметрах метода задать массив `params`, который преобразует все входящие параметры в массив, с которым можно оперировать, выглядит это так:

```csharp
void printConcat(params string[] strings)
{
    int i = 0;
	while (i < strings.Length)
	{
		Console.Write(strings[i++]);
	}
}
printConcat("Hello", " ", "World!", " Another text", ".");
    // Вывод: Hello World! Another text.
```

Как видно в данном случае мы работаем с простым массивом, при этом массив создаётся из параметров, т.е. нам не нужно самостоятельно инициализировать массив и подавать его, если бы у нас не было возможности использовать `params`.

## Про ссылки

То, с чем мы работаем на данный момент является фактическим значением. Когда мы подаём параметры в метод, то внутри локальной зоны видимости метода создаются копии переменных, с которыми мы работаем. 

В C# есть два вида переменных: ссылочные и типа значений. Ссылочная переменная имеет в себе ссылку на объект такого же типа данных, при этом тип значений представляет собой единичный экземпляр. На один объект при этом может быть несколько ссылок, и при изменении значения одной ссылки, значение изменяется везде, где есть ссылка на данный объект.

Все встроенные типы данных в C# помимо `string` являются типами значений. Поэтому когда мы передаём подобные переменные в метод как было сказано выше они копируются. Для того чтобы изменять уже существующий объект мы можем использовать ключевое слово `ref`, которое говорит что мы передаём объект как ссылку на уже существующий.

```csharp
void noRef(int a)
{
	a++;	
}

void withRef(ref int a)
{
	a++;	
}

int a = 5;

noRef(a);
Console.WriteLine(a); // 5

withRef(ref a);
Console.WriteLine(a); // 6
```

Когда мы используем ссылку мы должны это чётко написать, можно сказать что это своеобразный контракт, говорящий о том что мы согласны изменить уже существующую переменную. При этом когда мы подаём в параметры класс или другой ссылочный тип данных лучше насторожиться, так как в данном случае мы копируем не само значение, а лишь ссылку, но об этом позже. Помимо `ref` есть ещё и `in`, который гарантирует, что переменная не изменится. В данном случае мы передаём ссылку "только для чтения".

```csharp
void withIn(in int a)
{
	a++; // Ошибка, нельзя присвоить значение переменной
         // так как она только для чтения.
}
```

Если же мы хотим переменную проинициализировать внутри метода, то мы можем использовать ключевое слово `out`. Основное отличие от `ref` заключается в том, что в `ref` мы должны подавать проинициализированные переменные, при этом в `out` нам этого не нужно. Мы можем использовать `out` когда нам нужно вернуть несколько значений, помимо одного.

```csharp
int tryParse(string number, out int result)
{
	if (!Char.IsDigit(number[0]))
	{
		result = 0;
		return -1;
	}
	else
	{
		result = number[0] - '0';
	}
	
	for (int i = 1; i < number.Length; i++)
		if (!Char.IsDigit(number[i]))
		{
			return -1;
		}
		else
		{
			result = result * 10 + number[i] - '0';
		}
	
	return 0;
}

if (tryParse("475d84d", out int a) != -1)
{
	Console.WriteLine(a);
}
else
{
	Console.WriteLine("Произошла ошибка считывания, число: " + a);
} // Вывод: Произошла ошибка форматирования, число 475.
```

В данном примере мы написали метод который парсит строку в число, при этом данный метод возвращает при возникновении ошибки `-1`, в противном случае `0`. Также у нас инициализируется переменная с прочитанным числом, если ничего не было прочитано, то возвращаемое число будет равно `0`. Это очень удобно, так как мы возвращаем как число, так и говорим о том, что прозошла ошибка.
